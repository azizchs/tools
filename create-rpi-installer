#!/bin/bash -eu
#
# Create an installer kernel and initrd for Raspberry Pi
#

function out()
{
	local rc=$?

	trap - INT EXIT TERM HUP

	partumount "${TMP_DIR}"/boot/firmware || true
	partumount "${TMP_DIR}" || true
	rmdir "${TMP_DIR}" || true

	if [ "${KEEP}" -eq 1 ] ; then
		mv "${INITRD_DIR}" "${OUT_DIR}"/initrd.d
		echo "Temporary output directory: ${OUT_DIR}"
	else
		rm -rf "${INITRD_DIR}" "${OUT_DIR}"
	fi

	if [ "${rc}" -ne 0 ] ; then
		echo "Script failed" >&2
	fi

	exit "${rc}"
}

function usage()
{
	cat <<EOF
Usage: create-rpi-installer [-h] [-k] IMAGE [OUTFILE]

Create a Raspberry Pi installer kernel and initrd.

Positional arguments:
  IMAGE       The image from which to extract the kernel, initrd and DTBs to
              use as the base for the installer.
  OUTFILE     The filename of the installer. If not provided, defaults to
              'rpi-installer.tgz' in the current working directory.

Optional arguments:
  -h, --help  Show this help text and exit.
  -k, --keep  Keep the temporary initrd and installer directories.
EOF
}

KEEP=0
image=
outfile=

while [ $# -gt 0 ] ; do
	case "${1}" in
		-k|--keep)
			KEEP=1
			;;
		-h|--help)
			usage
			exit
			;;
		*)
			if [ -z "${image}" ]; then
				image=${1}
			elif [ -z "${outfile}" ] ; then
				outfile=${1}
			else
				usage
				exit 2
			fi
			;;
	esac
	shift
done

if [ -z "${image}" ] ; then
	usage
	exit 2
fi

if ! [ -e "${image}" ] ; then
	echo "No such image file: ${image}" >&2
	exit 1
fi

if [ -z "${outfile}" ] ; then
	outfile=${PWD}/rpi-installer.tgz
fi

TMP_DIR=$(mktemp -d)
INITRD_DIR=$(mktemp -d)
OUT_DIR=$(mktemp -d)
trap out INT TERM EXIT HUP

# Mount the image
partmount "${image}" 2 "${TMP_DIR}"
partmount "${image}" 1 "${TMP_DIR}"/boot/firmware

cd "${INITRD_DIR}"

# Extract the initrd
lz4cat "${TMP_DIR}"/boot/firmware/initrd.img | cpio -i

# Inject the installer init script
cat <<EOF >init
#!/bin/sh

echo "--- Loading installer initrd"

[ -d /dev ] || mkdir -m 0755 /dev
[ -d /root ] || mkdir -m 0700 /root
[ -d /sys ] || mkdir /sys
[ -d /proc ] || mkdir /proc
[ -d /tmp ] || mkdir /tmp
mkdir -p /var/lock
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
mount -t proc -o nodev,noexec,nosuid proc /proc

mount -t devtmpfs -o nosuid,mode=0755 udev /dev
mkdir /dev/pts
mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true

# Wait for the boot partition
echo "--- Waiting for /dev/mmcblk0p1"
while ! [ -b /dev/mmcblk0p1 ] ; do
    sleep .5
done

# Copy the installer
mkdir -p /boot
mount /dev/mmcblk0p1 /boot
cp /boot/install/install-rpi-image .
umount /boot

# Run the installer
./install-rpi-image

# Fall-back
/bin/sh
EOF
chmod 755 init

# Copy the tar binary (required for updating the installer)
cp "${TMP_DIR}"/usr/bin/tar usr/bin/

# The installer directory
mkdir -p "${OUT_DIR}"/install

# Recreate the initrd
find . | cpio -H newc -o | gzip -9 > "${OUT_DIR}"/install/initrd.img

# Copy the installer script
cp "$(dirname "$(readlink -e "${0}")")"/install-rpi-image "${OUT_DIR}"/install/

# Copy the dtbs and other files required by the Raspberry Pi firmware
cp "${TMP_DIR}"/boot/firmware/vmlinuz "${TMP_DIR}"/boot/firmware/*.dtb \
   "${TMP_DIR}"/boot/firmware/README "${OUT_DIR}"/install/

# Create a dummy overlays directory
mkdir "${OUT_DIR}"/install/overlays
touch "${OUT_DIR}"/install/overlays/README

# Create cmdline.txt
cat <<EOF >"${OUT_DIR}"/install/cmdline.txt
console=ttyAMA0,115200
EOF

# Create the installer config snippet
cat <<EOF >"${OUT_DIR}"/installcfg.txt
[all]
[gpio4=0]
arm_64bit=0
os_prefix=install/
overlay_prefix=overlays/
kernel=vmlinuz
initramfs initrd.img
cmdline=cmdline.txt
enable_uart=1
EOF

cd "${OUT_DIR}"
tar -czvf "${outfile}" .
