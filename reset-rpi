#!/usr/bin/env python3
#
# Reset other Raspberry Pis by pulling their RUN pin low
#

import argparse
from time import sleep
import RPi.GPIO as gpio

pin_map = {
    "slot-1": {"run": 40, "gpio4": 3},
    "slot-2": {"run": 38, "gpio4": 5},
    "slot-3": {"run": 36, "gpio4": 7},
    "slot-4": {"run": 32, "gpio4": 11},
    "slot-5": {"run": 26, "gpio4": 13},
    "slot-6": {"run": 24, "gpio4": 15},
    "slot-7": {"run": 22, "gpio4": 19},
}

parser = argparse.ArgumentParser()
parser.add_argument("-4", "--gpio4", nargs=1, choices=('0', '1'))
parser.add_argument("-n", "--no-reset", action="store_true")
parser.add_argument("slot", choices=('1', '2', '3', '4', '5', '6', '7'))
args = parser.parse_args()

run_pin = pin_map["slot-" + args.slot]["run"]
gpio4_pin = pin_map["slot-" + args.slot]["gpio4"]
gpio4_val = None if args.gpio4 is None else int(args.gpio4[0])

# Use board pin numbers
gpio.setmode(gpio.BOARD)

# Drive the gpio4 pin
if gpio4_val is not None:
    print("Pulling gpio4 pin ({}) {}".format(gpio4_pin,
                                             "high" if gpio4_val else "low"),
          flush=True)
    gpio.setup(gpio4_pin, gpio.OUT, initial=gpio4_val)

# Drive the run pin low and release it again
if not args.no_reset:
    print("Pulling run pin ({}) low".format(run_pin), flush=True)
    gpio.setup(run_pin, gpio.OUT, initial=0)
    sleep(0.5)
    print("Releasing run pin", flush=True)
    gpio.cleanup(run_pin)

# Wait long enough for the firmware to sample the state of gpio4 pin and
# then release it again
if gpio4_val is not None:
    sleep(20)
    print("Releasing gpio4 pin", flush=True)
    gpio.cleanup(gpio4_pin)
