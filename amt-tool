#!/usr/bin/env python

import argparse
import os
import re
import subprocess

from itertools import chain
from lxml import etree
from time import sleep


def run(command, stdin=None, die=False):
    """
    Run a subprocess with stdin
    """
    process = subprocess.Popen(command, stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate(stdin)
    if die and process.returncode != 0:
        raise Exception("Failed to run command: %s with error: %s" %
                        (command, stderr.decode("utf-8", "replace")))
    return stdout


def parse_xmls(xml):
    """
    Parse multiple XML documents

    Each document must commence with an XML document declaration, i.e.
    <?xml ...

    Works around a weird decision in `wsman` where it returns multiple XML
    documents in a single stream.
    """
    xmldecl = re.compile(b'<[?]xml\\s')
    xmldecls = xmldecl.finditer(xml)
    starts = [match.start() for match in xmldecls]
    ends = starts[1:] + [len(xml)]
    frags = (xml[start:end] for start, end in zip(starts, ends))
    return (etree.fromstring(frag) for frag in frags)


def parse_state_xml(xml):
    """
    Parse a power state wsman XML
    """
    namespaces = {
        "h": (
            "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/"
            "CIM_AssociatedPowerManagementService"
        ),
    }

    state = next(chain.from_iterable(
        doc.xpath('//h:PowerState/text()', namespaces=namespaces)
        for doc in parse_xmls(xml)
    ))

    # These are all power states that indicate that the system is
    # either ON or will resume function in an ON or Powered Up
    # state (e.g. being power cycled currently)
    if state in ('2', '3', '4', '5', '7', '9', '10', '14', '15', '16'):
        return 'on'
    elif state in ('6', '8', '12', '13'):
        return 'off'

    return 'unsupported (%s)' % state


def render_state_xml(state):
    """
    Render a power state wsman XML
    """
    states = {'on': '2', 'off': '8', 'cycle': '10'}
    xml = """<p:RequestPowerStateChange_INPUT xmlns:p="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_PowerManagementService">
  <p:PowerState>%s</p:PowerState>
  <p:ManagedElement xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing"
                    xmlns:wsman="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd">
    <wsa:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</wsa:Address>
    <wsa:ReferenceParameters>
      <wsman:ResourceURI>http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ComputerSystem</wsman:ResourceURI>
      <wsman:SelectorSet>
        <wsman:Selector Name="CreationClassName">CIM_ComputerSystem</wsman:Selector>
        <wsman:Selector Name="Name">ManagedSystem</wsman:Selector>
      </wsman:SelectorSet>
    </wsa:ReferenceParameters>
  </p:ManagedElement>
</p:RequestPowerStateChange_INPUT>""" % states[state]
    return xml


class AMTPower(object):
    """
    Intel AMT Power driver

    There are a LOT of possible power states per AMT
      1: Other                      10: Master Bus Reset
      2: On                         11: Diagnostic Interrupt (NMI)
      3: Sleep - Light              12: Off - Soft Graceful
      4: Sleep - Deep               13: Off - Hard Graceful
      5: Power Cycle (Off - Soft)   14: Master Bus Reset Graceful
      6: Off - Hard                 15: Power Cycle (Off-Soft Graceful)
      7: Hibernate (Off - Soft)     16: Power Cycle (Off-Hard Graceful)
      8: Off - Soft                 17: Diagnostic Interrupt (INIT)
      9: Power Cycle (Off-Hard)
    """
    def __init__(self, hostname=None, password=None):
        self.hostname = os.getenv("AMT_HOST", hostname)
        self.password = os.getenv("AMT_PASSWORD", password)

    def _do_action(self, action):
        """
        Perform a power action using wsman
        """

        wsman_power_schema_uri = (
            'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/'
            'CIM_PowerManagementService?SystemCreationClassName='
            '"CIM_ComputerSystem"&SystemName="Intel(r) AMT"'
            '&CreationClassName="CIM_PowerManagementService"&Name='
            '"Intel(r) AMT Power Management Service"'
        )
        wsman_status_schema_uri = (
            'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/'
            'CIM_AssociatedPowerManagementService'
        )
        wsman_opts = (
            '--port', '16992', '--hostname', self.hostname, '--username',
            'admin', '--password', self.password, '--noverifypeer',
            '--noverifyhost'
        )

        if action in ('on', 'off', 'cycle'):
            stdin = render_state_xml(action)
            wsman_opts += ('--input', '-',)
            wsman_action = (
                'invoke', '--method', 'RequestPowerStateChange',
                wsman_power_schema_uri)
            command = ('wsman',) + wsman_opts + wsman_action

        elif action == 'status':
            stdin = None  # No input for status query
            wsman_opts += ('--optimize', '--encoding', 'utf-8',)
            wsman_action = ('enumerate', wsman_status_schema_uri)
            command = ('wsman',) + wsman_opts + wsman_action

        else:
            print("Unknown power action requested: %s" % action)
            return ""

        return run(command, stdin=stdin)

    def _do_action_verify(self, action, state, error):
        """
        Perform a power action and verify the resulting power state
        """
        self._do_action(action)
        # Check power state several times. It usually takes a second or two to
        # get the correct state.
        for _ in range(10):
            if self.status() == state:
                return
            sleep(1)

        raise Exception(error)

    # -------------------------------------------------------------------------
    # Public methods

    def status(self):
        """
        Get the machine's power staus
        """
        xml = None
        for _ in range(10):
            xml = self._do_action("status")
            if xml is not None and len(xml) > 0:
                return parse_state_xml(xml)

            # Wait 1 second between retries. AMT controllers are generally
            # very light and may not be comfortable with more frequent
            # queries.
            sleep(1)

        raise Exception("Failed to query power status.")

    def on(self):
        """
        Turn the machine on
        """
        self._do_action_verify("on", "on", "Machine is not powering on.")

    def off(self):
        """
        Turn the machine off
        """
        self._do_action_verify("off", "off", "Machine is not powering off.")

    def cycle(self):
        """
        Power cycle the machine
        """
        self._do_action_verify("cycle", "on", "Machine is not power cycling.")


# -----------------------------------------------------------------------------
# Main entry point

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("action", choices=["power-status", "power-on",
                                           "power-off", "power-cycle"])
    args = parser.parse_args()
    func = getattr(AMTPower(), args.action[6:])
    print(func())
