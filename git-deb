#!/bin/bash -eu
#
# Helper script for managing Debian/Ubuntu package git repos
#

function out()
{
	local rc=$?

	trap - INT TERM EXIT HUP

	if [ ${rc} -ne 0 ] ; then
		pr_error "Script failed"
	fi

	exit "${rc}"
}

function pr_error()
{
	echo -e "\033[31m${*}\033[0m" 1>&2
}

function set_globals()
{
	local remote

	remote=$(git remote get-url origin)
	repo=${remote##*/}

	if [ "${repo}" = kteam-tools ] ; then
		SUBJECT_PREFIX="kteam-tools][PATCH"
	else
		if [ -z "${RELEASE}" ] ; then
			# shellcheck disable=SC1091
			. debian/debian.env
			RELEASE=$(dpkg-parsechangelog -l "${DEBIAN}"/changelog \
										  -S Distribution)
			RELEASE=${RELEASE^}
		fi

		SUBJECT_PREFIX="${RELEASE}][PATCH"
		if [ "${NO_SRU}" -eq 0 ] ; then
			SUBJECT_PREFIX="SRU][${SUBJECT_PREFIX}"
		fi
	fi

	if [ "${VERSION}" -gt 0 ] ; then
		SUBJECT_PREFIX="${SUBJECT_PREFIX} v${VERSION}"
	fi

	if [ "${RESEND}" -gt 0 ] ; then
		SUBJECT_PREFIX="${SUBJECT_PREFIX} RESEND"
	fi
}

function send_patch()
{
	local opts=()

	# Additional options
	if [ "${DRY_RUN}" -eq 1 ] ; then
		opts+=("--dry-run")
	fi

	git send-email .outgoing/*.patch --suppress-cc=all "${opts[@]}"
}

function _get_first_buglink()
{
	for f in "${@}" ; do
		grep -m1 '^BugLink: ' "${f}" && return
	done
}

function do_format_patch()
{
	local buglink url subject blurb
	local opts=()

	# Additional options
	if [ "${COVER_LETTER}" -eq 1 ] ; then
		opts+=("--cover-letter")
	fi
	if [ -n "${SUBJECT_PREFIX}" ] ; then
		opts+=("--subject-prefix=${SUBJECT_PREFIX}")
	fi
	if [ -n "${IN_REPLY_TO}" ] ; then
		opts+=("--in-reply-to=${IN_REPLY_TO}")
		opts+=("--thread")
	fi

	# Create the patchset
	rm -rf .outgoing/
	git format-patch -o .outgoing/ "${opts[@]}" "${@}"

	# Try to fill in the cover letter
	if [ -f .outgoing/0000-cover-letter.patch ] ; then
		subject="*** SUBJECT HERE ***"
		blurb="*** BLURB HERE ***"

		buglink=$(_get_first_buglink .outgoing/*.patch)
		if [ -n "${buglink}" ] ; then
			buglink=${buglink#BugLink: }
			url=${buglink%% *}
			if [ "${url}" = "${buglink}" ] ; then
				# Try to query launchpad
				true
			else
				# Buglink contains a subject, so must be a private bug
				subject=${buglink#* }
				subject=${subject:1:-1}
			fi
		fi
		sed -i \
			-e "s,\*\*\* SUBJECT HERE \*\*\*,${subject}," \
			-e "s,\*\*\* BLURB HERE \*\*\*,${blurb}," \
			.outgoing/0000-cover-letter.patch
	fi

	if [ "${DRY_RUN}" -eq 1 ] ; then
		echo "git format-patch -o .outgoing/ ${opts[*]} ${*}"
		for p in .outgoing/*.patch ; do
			echo
			echo -e "\e[33m*** ${p#*/} ***\e[0m"
			echo
			colordiff < "${p}"
		done
	fi
}

function do_send_patch()
{
	do_format_patch -1
	send_patch
}

function usage()
{
	cat <<EOF
Usage: git-deb [-c] [-d] [-h] [-i MSG_ID] [-r RELEASE] [-v NUM] COMMAND [ARGS]

Helper script for managing Ubuntu package git repos.

Supported commands:
  format-patch  Create patch (series).
  send-patch    Send a single commit as a patch email.

Optional arguments:
  -c, --cover-letter        Add a cover letter.
  -d, --dry-run             Don't send the email.
  -h, --help                Show this help text.
  -i, --in-reply-to MSG_ID  Reply to the given MSG_ID.
  -r, --release RELEASE     The release to include in the subject prefix.
  -s, --resend              Add RESEND to the subject prefix.
  -u, --no-sru              Don't include [SRU] in the subject prefix.
  -v, --version NUM         The revision number of the patch to include in the
                            subject prefix.
EOF
}

# -----------------------------------------------------------------------------
# Main entry point

COVER_LETTER=0
DRY_RUN=0
IN_REPLY_TO=
RELEASE=
RESEND=0
NO_SRU=0
VERSION=0
SUBJECT_PREFIX=

cmd=
args=()

while [ ${#} -gt 0 ] ; do
	case ${1} in
		-c|--cover-letter)
			COVER_LETTER=1
			;;
		-d|--dry-run)
			DRY_RUN=1
			;;
		-h|--help)
			usage
			exit
			;;
		-i|--in-reply-to)
			shift
			IN_REPLY_TO=${1}
			;;
		-r|--release)
			shift
			RELEASE=${1}
			;;
		-s|--resend)
			RESEND=1
			;;
		-u|--no-sru)
			NO_SRU=1
			;;
		-v|--version)
			shift
			VERSION=${1}
			;;
		format-patch|send-patch)
			cmd=${1//-/_}
			;;
		*)
			if [ -z "${cmd}" ] ; then
				pr_error "Unexpected argument: ${1}" >&2
				exit 1
			fi
			args=("${@}")
			break
			;;
	esac
	shift
done

if [ -z "${cmd}" ] ; then
	usage
	exit 2
fi

set_globals
do_"${cmd}" "${args[@]}"
