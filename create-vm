#!/bin/bash -eu
#
# Create a base libvirt guest VM
#

function pr_error()
{
	echo -e "\033[31m${*}\033[0m" 1>&2
}


function print_var()
{
	local var val

	for var in "${@}" ; do
		val=${!var}
		if [ -n "${val}" ] ; then
			printf "%-13s: %s\n" "${var}" "${val}"
		fi
	done
}


function has_grub()
{
	[ "${ARCH}" = "amd64" ] || [ "${ARCH}" = "i386" ]
}


function has_direct_boot()
{
	[ "${ARCH}" = "armhf" ]
}


function mount_image()
{
	local image=${1} mountp=${2}
	local kernel

	# HACK: guestmount needs to be able to read the latest kernel
	kernel=$(find /boot/ -maxdepth 1 -name 'vmlinuz-*' | sort -V | tail -1)
	test -r "${kernel}" || sudo chmod 644 "${kernel}"

	guestmount --pid-file "${mountp}.pid" -a "${image}" -m /dev/sda1 --rw \
			   -o dev -o allow_root "${mountp}"
}


function unmount_image()
{
	local mountp=${1}
	local pid count

	pid=$(cat "${mountp}.pid")
	guestunmount "${mountp}"

	count=10
	while kill -0 "${pid}" 2>/dev/null && [ ${count} -gt 0 ] ; do
		sleep 1
		((count--))
	done

	if [ ${count} -eq 0 ] ; then
		pr_error "Failed to unmount image (timeout)"
		exit 1
	fi

	rm -f "${mountp}.pid"
}


function download_image()
{
	local url=${1}
	local tmpf tmpf2 tmpd

	tmpf=$(mktemp)
	tmpf2=$(mktemp)
	# shellcheck disable=SC2064
	trap "rm -f ${tmpf} ${tmpf2}" EXIT INT TERM HUP

	# Download the cloud image
	wget -O "${tmpf}" "${url}"

	if [ -n "${KERNEL}" ] ; then
		tmpd=$(mktemp -d)
		# shellcheck disable=SC2064
		trap "rm -rf ${tmpf} ${tmpf2} ${tmpd}" EXIT INT TERM HUP

		mount_image "${tmpf}" "${tmpd}"
		sudo cp "${tmpd}/boot/vmlinuz" "${KERNEL}"
		sudo cp "${tmpd}/boot/initrd.img" "${INITRD}"
		unmount_image "${tmpd}"
		rm -rf "${tmpd}"
	fi

	# Create the libvirt volume for the OS image
	cat <<EOF >"${tmpf2}"
<volume type='file'>
  <name>${OS_IMAGE}</name>
  <capacity unit='bytes'>0</capacity>
  <target>
    <format type='qcow2'/>
  </target>
</volume>
EOF
	virsh vol-create --pool default "${tmpf2}"
	virsh vol-upload --pool default "${OS_IMAGE}" "${tmpf}"
	virsh vol-resize --pool default "${OS_IMAGE}" "${SIZE}"G

	rm -f "${tmpf}" "${tmpf2}"
	trap - EXIT INT TERM HUP
}


function download_fedora_image()
{
	local url pattern name

	if [ "${RELEASE}" -gt 27 ] ; then
		url=https://download.fedoraproject.org/pub/fedora/linux/releases/${RELEASE}/Cloud/${ARCH}/images
	else
		url=https://download.fedoraproject.org/pub/fedora/linux/releases/${RELEASE}/CloudImages/${ARCH}/images
	fi

	pattern="Fedora-Cloud-Base-${RELEASE}-.*.${ARCH}.qcow2"
	name=$(wget -q -O - "${url}" | \
			   sed -n -e 's/.*href="\([^"]*\).*/\1/p' | \
			   grep "${pattern}")

	url=${url}/${name}

	download_image "${url}"
}


function download_debian_image()
{
	local num name url release

	case "${RELEASE}" in
		jessie)  num=8 ;;
		stretch) num=9 ;;
	esac

	name=debian-${num}-openstack-${ARCH}.qcow2
	url=https://cdimage.debian.org/cdimage/openstack/current-${num}/${name}

	if download_image "${url}" ; then
		return
	fi

	url=https://cdimage.debian.org/cdimage/openstack/archive
	release=$(wget -q -O - "${url}" | \
				  sed -n -e "s,.* href=\"\(${num}\.[^/]*\).*,\1,p" | \
				  sort -V | tail -1)
	name=debian-${release}-openstack-${ARCH}.qcow2
	url=${url}/${release}/${name}

	download_image "${url}"
}


function download_ubuntu_image()
{
	local suffix name url

	suffix=
	if [ "${RELEASE}" = "precise" ] || [ "${RELEASE}" = "trusty" ] || \
		   [ "${RELEASE}" = "xenial" ] ; then
		suffix="-disk1"
		if [ "${UEFI}" -eq 1 ] ; then
			suffix="-uefi1"
		fi
	fi

	name=${RELEASE}-server-cloudimg-${ARCH}${suffix}.img
	url=https://cloud-images.ubuntu.com/${RELEASE}/current/${name}

	download_image "${url}"
}


function create_config_drive()
{
	local public_key tmpf tmpf2 tmpd

	public_key=$(cat ~/.ssh/id_rsa.pub)
	tmpf=$(mktemp)
	tmpf2=$(mktemp)
	tmpd=$(mktemp -d)
	# shellcheck disable=SC2064
	trap "rm -rf ${tmpf} ${tmpf2} ${tmpd}" EXIT INT TERM HUP

	# meta data
	cat <<EOF >"${tmpd}/meta-data"
{ instance-id: $(uuidgen) }
EOF

	# user data
	cat <<EOF >"${tmpd}/user-data"
#cloud-config

hostname: ${NAME}.localdomain
manage_etc_hosts: localhost

chpasswd: { expire: false }
password: ${VENDOR}
ssh_authorized_keys: [ ${public_key} ]
ssh_pwauth: true

# Datasource timeout
max_wait: 2

# Set the hostname early on first boot
bootcmd:
  - [ cloud-init-per, once, hostname, hostname, ${NAME} ]
EOF

	if has_grub ; then
		cat <<EOF >>"${tmpd}/user-data"

# Fix grub
# Some images are having problems finding the boot device so we reinstall grub
# which seems to fix that. While at it, enable the boot menu and purge the
# infamous 40-force-partuuid.cfg config file to prevent booting without an
# initrd first.
runcmd:
  - |
    if ! test -e /etc/cloud/create-vm ; then
    rm -f /etc/default/grub.d/40-force-partuuid.cfg
    test -d /etc/default/grub.d || mkdir /etc/default/grub.d
    cat <<__EOF__ > /etc/default/grub.d/99-create-vm.cfg
    unset GRUB_HIDDEN_TIMEOUT GRUB_TIMEOUT_STYLE
    GRUB_TIMEOUT=2
    GRUB_CMDLINE_LINUX_DEFAULT="console=tty1 console=ttyS0"
    __EOF__
    grub-install /dev/vda
    update-grub
    date -R > /etc/cloud/create-vm
    fi
EOF
	fi

	genisoimage -ldots -allow-lowercase -allow-multidot -l -J -r \
				-o "${tmpf}" -V cidata "${tmpd}"

	# Create the libvirt volume for the config drive
	cat <<EOF >"${tmpf2}"
<volume type='file'>
  <name>${CONFIG_DRIVE}</name>
  <capacity unit='bytes'>0</capacity>
  <target>
    <format type='raw'/>
  </target>
</volume>
EOF
	virsh vol-create --pool default "${tmpf2}"
	virsh vol-upload --pool default "${CONFIG_DRIVE}" "${tmpf}"

	rm -rf "${tmpf}" "${tmpf2}" "${tmpd}"
	trap - EXIT INT TERM HUP
}


function define_vm()
{
	local tmpf
	export NAME UUID OS_LOADER KERNEL_PATH INITRD_PATH KERNEL_CMDLINE \
		   OS_IMAGE_PATH CONFIG_DRIVE_PATH MAC_ADDRESS

	tmpf=$(mktemp)
	# shellcheck disable=SC2064
	trap "rm -f ${tmpf}" EXIT INT TERM HUP

	UUID=$(uuidgen)
	if [ "${UEFI}" -eq 1 ] ; then
		OS_LOADER="
<loader readonly='yes' type='pflash'>/usr/share/OVMF/OVMF_CODE.fd</loader>
<nvram>/var/lib/libvirt/qemu/nvram/${NAME}_VARS.fd</nvram>
"
	fi

	if has_direct_boot ; then
		KERNEL_PATH=$(virsh vol-path --pool default "${KERNEL}")
		INITRD_PATH=$(virsh vol-path --pool default "${INITRD}")
	fi

	OS_IMAGE_PATH=$(virsh vol-path --pool default "${OS_IMAGE}")
	CONFIG_DRIVE_PATH=$(virsh vol-path --pool default "${CONFIG_DRIVE}")
	MAC_ADDRESS="52:54:00:${UUID:0:2}:${UUID:2:2}:${UUID:4:2}"

	# Create the domain XML and define the VM
	envsubst < "$(realpath -e "${0}").d/domain-${ARCH}.xml" > "${tmpf}"
	virsh define "${tmpf}"

	rm -f "${tmpf}"
	trap - EXIT INT TERM HUP
}


function usage()
{
	cat <<EOF
Usage: create-vm [-a ARCH] [-d] [-f] [-h] [-u] DIST [NAME]

Create a libvirt guest VM.

Positional arguments:
  DIST  A recognized distrbution, like bionic, stretch, fedora-26, ...
  NAME  The libvirt domain name, defaults to <DIST>[-uefi][-<ARCH>] if not
        specified.

Optional arguments:
  -a, --arch ARCH  Architecture of the VM (defaults to the host architecture).
  -d, --debug      Enable debugging (set -x).
  -f, --force      Force the recreation of an existing VM.
  -h, --help       Show this help text.
  -s, --size SIZE  Image size in GB. If not specified, defaults to 8(GB).
  -u, --uefi       Configure the VM to boot from UEFI.
EOF
}


# -----------------------------------------------------------------------------
# Main entry point

ARCH=
FORCE=0
UEFI=0
DIST=
NAME=
SIZE=8

while [ ${#} -gt 0 ] ; do
	case ${1} in
		-a|--arch)
			ARCH=${2}
			shift
			;;
		-d|--debug)
			export LIBGUESTFS_DEBUG=1
			set -x
			;;
		-f|--force)
			FORCE=1
			;;
		-h|--help)
			usage
			exit
			;;
		-s|--size)
			SIZE=${2}
			shift
			;;
		-u|--uefi)
			UEFI=1
			;;
		-*)
			pr_error "Unexpected option: ${1}"
			exit 2
			;;
		*)
			if [ -z "${DIST}" ] ; then
				DIST=${1}
			elif [ -z "${NAME}" ] ; then
				NAME=${1}
			else
				pr_error "Unexpected argument: ${1}"
				exit 2
			fi
			;;
	esac
	shift
done

if [ -z "${DIST}" ] ; then
	usage
	exit 2
fi

# -----------------------------------------------------------------------------
# Set global variables

# The image vendor and release
case "${DIST}" in
	*-*)
		VENDOR=${DIST%-*}
		RELEASE=${DIST#*-}
		;;
	jessie|stretch)
		VENDOR=debian
		RELEASE=${DIST}
		;;
	*)
		VENDOR=ubuntu
		RELEASE=${DIST}
		;;
esac

# The name of the VM
if [ -z "${NAME}" ] ; then
	NAME=${VENDOR}-${RELEASE}
	if [ ${UEFI} -eq 1 ] ; then
		NAME=${NAME}-uefi
	fi
	if [ -n "${ARCH}" ] ; then
		NAME=${NAME}-${ARCH}
	fi
fi

# The vendor specific architecture name
case "${VENDOR}" in
	fedora|centos)
		if [ -z "${ARCH}" ] ; then
			ARCH=$(dpkg-architecture -q DEB_HOST_GNU_CPU)
		fi
		;;
	*)
		if [ -z "${ARCH}" ] ; then
			ARCH=$(dpkg-architecture -q DEB_HOST_ARCH)
		fi
		;;
esac

# The OS image and config drive
OS_IMAGE=${NAME}.qcow2
CONFIG_DRIVE=${NAME}-config.iso

# The kernel, initrd and cmdline (for direct boot architectures)
KERNEL=
INITRD=
KERNEL_CMDLINE=
if has_direct_boot ; then
	KERNEL=${NAME}-kernel
	INITRD=${NAME}-initrd
	KERNEL_CMDLINE="root=LABEL=cloudimg-rootfs"
fi

# Sanity check
if [ "${RELEASE}" = "precise" ] && [ "${UEFI}" -eq 1 ] ; then
	pr_error "Precise does not support boot from UEFI"
	exit 1
fi

print_var ARCH FORCE DIST OS_IMAGE CONFIG_DRIVE KERNEL INITRD KERNEL_CMDLINE \
		  NAME RELEASE VENDOR
echo

# -----------------------------------------------------------------------------
# Purge existing VM

if virsh vcpuinfo "${NAME}" >/dev/null 2>&1 ; then
	if [ "${FORCE}" -eq 0 ] ; then
		pr_error "VM '${NAME}' exists already. Use -f, --force to recreate it."
		exit 1
	fi
	virsh destroy "${NAME}" || true
	for vol in "${OS_IMAGE}" "${CONFIG_DRIVE}" "${KERNEL}" "${INITRD}" ; do
		virsh vol-delete --pool default "${vol}" 2>/dev/null || true
	done
	virsh undefine "${NAME}" || true
fi

# -----------------------------------------------------------------------------
# Download and resize the cloud image

if virsh vol-info --pool default "${OS_IMAGE}" >/dev/null 2>&1 ; then
	echo "Image '${OS_IMAGE}' exists already."
else
	download_"${VENDOR}"_image
fi

# -----------------------------------------------------------------------------
# Create the config drive

if virsh vol-info --pool default "${CONFIG_DRIVE}" >/dev/null 2>&1 ; then
	echo "Config drive '${CONFIG_DRIVE}' exists already."
else
	create_config_drive
fi

# -----------------------------------------------------------------------------
# Define the VM

define_vm
