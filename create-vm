#!/bin/bash -eu
#
# Create a base libvirt guest VM
#

# Mapping between distro and VM architecture names
declare -A ARCH_MAP=(
	# Debian
	[i386]=i686
	[amd64]=x86_64
	[s390x]=s390x
	# RHEL
	[i686]=i686
	[x86_64]=x86_64
)

function pr_error()
{
	echo -e "\033[31m${*}\033[0m" 1>&2
}

function pr_info()
{
	echo -e "\033[33m${*}\033[0m"
}

function print_var()
{
	local var val

	for var in "${@}" ; do
		val=${!var}
		if [ -n "${val}" ] ; then
			pr_info "$(printf "%-13s: %s\n" "${var}" "${val}")"
		fi
	done
}

function has_direct_boot()
{
	[ "${ARCH}" = "armhf" ]
}

function mount_image()
{
	local image=${1} mountp=${2}
	local kernel

	# HACK: guestmount needs to be able to read the latest kernel
	kernel=$(find /boot/ -maxdepth 1 -name 'vmlinuz-*' | sort -V | tail -1)
	test -r "${kernel}" || sudo chmod 644 "${kernel}"

	guestmount --pid-file "${mountp}.pid" -a "${image}" -m /dev/sda1 --rw \
			   -o dev -o allow_root "${mountp}"
}

function unmount_image()
{
	local mountp=${1}
	local pid count

	pid=$(cat "${mountp}.pid")
	guestunmount "${mountp}"

	count=10
	while kill -0 "${pid}" 2>/dev/null && [ ${count} -gt 0 ] ; do
		sleep 1
		((count--))
	done

	if [ ${count} -eq 0 ] ; then
		pr_error "Failed to unmount image (timeout)"
		exit 1
	fi

	rm -f "${mountp}.pid"
}

function download_image()
{
	local url=${1}
	local tmpf tmpf2 image tmpd

	tmpf=$(mktemp)
	tmpf2=$(mktemp)
	# shellcheck disable=SC2064
	trap "rm -f ${tmpf} ${tmpf2}" EXIT INT TERM HUP

	# Select the image to use
	if [ -n "${IMAGE}" ] ; then
		# Use the provided image
		cp "${IMAGE}" "${tmpf}"
	else
		# Download a cloud image if necessary/requested
		image=${IMAGES_DIR}/${url##*/}
		if [ "${DOWNLOAD}" -eq 1 ] || ! [ -e "${image}" ] ; then
			sudo wget -O "${image}" "${url}"
		fi
		cp "${image}" "${tmpf}"
	fi

	# Extract the kernel and initrd from the image for direct boot
	if has_direct_boot ; then
		tmpd=$(mktemp -d)
		# shellcheck disable=SC2064
		trap "rm -rf ${tmpf} ${tmpf2} ${tmpd}" EXIT INT TERM HUP

		mount_image "${tmpf}" "${tmpd}"

		# Create the libvirt volume for the kernel
		cat <<EOF >"${tmpf2}"
<volume type='file'>
  <name>${KERNEL}</name>
  <capacity unit='bytes'>0</capacity>
  <target>
    <format type='raw'/>
  </target>
</volume>
EOF
		virsh vol-create --pool default "${tmpf2}"
		virsh vol-upload --pool default "${KERNEL}" "${tmpd}/boot/vmlinuz"

		# Create the libvirt volume for the initrd
		cat <<EOF >"${tmpf2}"
<volume type='file'>
  <name>${INITRD}</name>
  <capacity unit='bytes'>0</capacity>
  <target>
    <format type='raw'/>
  </target>
</volume>
EOF
		virsh vol-create --pool default "${tmpf2}"
		virsh vol-upload --pool default "${INITRD}" "${tmpd}/boot/initrd.img"

		unmount_image "${tmpd}"
		rm -rf "${tmpd}"
	fi

	# Create the libvirt volume for the OS image
	cat <<EOF >"${tmpf2}"
<volume type='file'>
  <name>${OS_IMAGE}</name>
  <capacity unit='bytes'>0</capacity>
  <target>
    <format type='qcow2'/>
  </target>
</volume>
EOF
	virsh vol-create --pool default "${tmpf2}"
	virsh vol-upload --pool default "${OS_IMAGE}" "${tmpf}"
	virsh vol-resize --pool default "${OS_IMAGE}" "${SIZE}"G

	rm -f "${tmpf}" "${tmpf2}"
	trap - EXIT INT TERM HUP
}

function download_fedora_image()
{
	local url pattern name

	if [ "${RELEASE}" -gt 27 ] ; then
		url=https://download.fedoraproject.org/pub/fedora/linux/releases/${RELEASE}/Cloud/${ARCH}/images
	else
		url=https://download.fedoraproject.org/pub/fedora/linux/releases/${RELEASE}/CloudImages/${ARCH}/images
	fi

	pattern=">Fedora-Cloud-Base-${RELEASE}-.*\.${ARCH}\.qcow2<"
	name=$(wget -q -O - "${url}" | grep -oP "${pattern}" | tr -d '><')

	url=${url}/${name}

	download_image "${url}"
}

function download_debian_image()
{
	local num name url release

	case "${RELEASE}" in
		jessie)  num=8  ;;
		stretch) num=9  ;;
		buster)  num=10 ;;
	esac

	name=debian-${num}-openstack-${ARCH}.qcow2
	url=https://cdimage.debian.org/cdimage/openstack/current-${num}/${name}

	if download_image "${url}" ; then
		return
	fi

	url=https://cdimage.debian.org/cdimage/openstack/archive
	release=$(wget -q -O - "${url}" | grep -oP ">${num}\.[^/]*/<" | \
				  tr -d '>/<' | sort -V | tail -1)
	name=debian-${release}-openstack-${ARCH}.qcow2
	url=${url}/${release}/${name}

	download_image "${url}"
}

function download_ubuntu_image()
{
	local suffix name url

	suffix=
	if [ "${RELEASE}" = "precise" ] || [ "${RELEASE}" = "trusty" ] || \
		   [ "${RELEASE}" = "xenial" ] ; then
		suffix="-disk1"
		if [ "${UEFI}" -eq 1 ] ; then
			suffix="-uefi1"
		fi
	fi

	name=${RELEASE}-server-cloudimg-${ARCH}${suffix}.img
	url=https://cloud-images.ubuntu.com/${RELEASE}/current/${name}

	download_image "${url}"
}

function create_config_drive()
{
	local public_key tmpf tmpf2 tmpd

	public_key=$(cat ~/.ssh/id_rsa.pub)
	tmpf=$(mktemp)
	tmpf2=$(mktemp)
	tmpd=$(mktemp -d)
	# shellcheck disable=SC2064
	trap "rm -rf ${tmpf} ${tmpf2} ${tmpd}" EXIT INT TERM HUP

	# meta data
	cat <<EOF >"${tmpd}/meta-data"
{ instance-id: $(uuidgen) }
EOF

	# user data
	cat <<EOF >"${tmpd}/user-data"
#cloud-config

hostname: ${NAME}.localdomain
manage_etc_hosts: localhost

chpasswd: { expire: false }
password: ${VENDOR}
ssh_authorized_keys: [ ${public_key} ]
ssh_pwauth: true

# Datasource timeout
max_wait: 2

# Set the hostname early on first boot
bootcmd:
  - [ cloud-init-per, once, hostname, hostname, ${NAME} ]

# Copy the content of the config drive and run the create-vm init script
runcmd:
  - |
    if ! [ -d /etc/cloud/cidata ] ; then
    test -d /mnt/cidata || mkdir /mnt/cidata
    dev=\$(findfs LABEL=cidata)
    mount \${dev} /mnt/cidata
    cp -aR /mnt/cidata/ /etc/cloud/
    umount /mnt/cidata
    /etc/cloud/cidata/create-vm &
    fi
EOF

	# Copy the create-vm init script
	cp "${CONFIG_DIR}"/create-vm/create-vm "${tmpd}"
	sed -i -e "s,__REBOOT__,${REBOOT}," "${tmpd}"/create-vm

	# Copy the APT ESM sources list
	if [ -e "${CONFIG_DIR}/${RELEASE}-esm-ppa.list" ] ; then
		cp "${CONFIG_DIR}/${RELEASE}-esm-ppa.list" "${tmpd}"/esm-ppa.list
	fi

	# Create the config drive ISO image
	genisoimage -ldots -allow-lowercase -allow-multidot -l -J -r \
				-o "${tmpf}" -V cidata "${tmpd}"

	# Create the libvirt volume for the config drive
	cat <<EOF >"${tmpf2}"
<volume type='file'>
  <name>${CONFIG_DRIVE}</name>
  <capacity unit='bytes'>0</capacity>
  <target>
    <format type='raw'/>
  </target>
</volume>
EOF
	virsh vol-create --pool default "${tmpf2}"
	virsh vol-upload --pool default "${CONFIG_DRIVE}" "${tmpf}"

	rm -rf "${tmpf}" "${tmpf2}" "${tmpd}"
	trap - EXIT INT TERM HUP
}

function define_vm()
{
	local tmpf

	tmpf=$(mktemp)
	# shellcheck disable=SC2064
	trap "rm -f ${tmpf}" EXIT INT TERM HUP

	if [ "${UEFI}" -eq 1 ] ; then
		# shellcheck disable=SC2089
		XML_OS_LOADER="
<loader readonly='yes' type='pflash'>/usr/share/OVMF/OVMF_CODE.fd</loader>
<nvram>/var/lib/libvirt/qemu/nvram/${NAME}_VARS.fd</nvram>
"
	fi

	if has_direct_boot ; then
		XML_KERNEL_PATH=$(virsh vol-path --pool default "${KERNEL}")
		XML_INITRD_PATH=$(virsh vol-path --pool default "${INITRD}")
		XML_KERNEL_CMDLINE="root=LABEL=cloudimg-rootfs"
	fi

	XML_UUID=$(uuidgen)
	XML_OS_IMAGE_PATH=$(virsh vol-path --pool default "${OS_IMAGE}")
	XML_CONFIG_DRIVE_PATH=$(virsh vol-path --pool default "${CONFIG_DRIVE}")
	XML_MAC_ADDRESS="52:54:00:${XML_UUID:0:2}:${XML_UUID:2:2}:${XML_UUID:4:2}"
	XML_ARCH=${ARCH_MAP["${ARCH}"]}

	# Export the variables for the domain XML
	export XML_NAME=${NAME}
	export XML_VCPU=${VCPU}
	export XML_CPU=${CPU}
	export XML_MEMORY=${MEMORY}
	# shellcheck disable=SC2090
	export XML_OS_LOADER XML_KERNEL_PATH XML_INITRD_PATH XML_KERNEL_CMDLINE \
		   XML_UUID XML_OS_IMAGE_PATH XML_CONFIG_DRIVE_PATH XML_MAC_ADDRESS \
		   XML_ARCH

	# Create the domain XML and define the VM
	envsubst < "${CONFIG_DIR}/create-vm/domain-${XML_ARCH}.xml" > \
			 "${tmpf}"
	virsh define "${tmpf}"

	rm -f "${tmpf}"
	trap - EXIT INT TERM HUP
}

function usage()
{
	cat <<EOF
Usage: create-vm [-a ARCH] [-d] [-f] [-h] [-i IMAGE] [-s SIZE] [-t TYPE] [-u]
                 DIST [NAME]

Create a libvirt guest VM.

Positional arguments:
  DIST  A recognized distrbution, like bionic, stretch, fedora-26, ...
  NAME  The libvirt domain name. If not specified, defaults to
        <DIST>[-uefi][-<ARCH>].

Optional arguments:
  -a, --arch ARCH    Architecture of the VM. If not specified, defaults to the
                     host architecture.
  -d, --debug        Enable debugging (set -x).
  -f, --force        Force the recreation of an existing VM.
  -h, --help         Show this help text and exit.
  -i, --image IMAGE  Use image <IMAGE> as the guest VM image.
  -o, --download     Download and use a new cloud image rather than using an
                     already cached image.
  -r, --reboot       Configure the VM to automatically reboot after the
                     first boot initialization is done.
  -s, --size SIZE    Image size in GB. If not specified, defaults to 8(GB).
  -t, --type TYPE    Create a VM of type <TYPE>. Valid types are:
                       dep8:  For dep8 kernel testing.
  -u, --uefi         Configure the VM to boot from UEFI.
EOF
}

# -----------------------------------------------------------------------------
# Main entry point

ARCH=
FORCE=0
IMAGE=
DOWNLOAD=0
REBOOT=0
SIZE=8
TYPE=
UEFI=0
DIST=
NAME=

while [ ${#} -gt 0 ] ; do
	case ${1} in
		-a|--arch)
			ARCH=${2}
			shift
			;;
		-d|--debug)
			export LIBGUESTFS_DEBUG=1
			set -x
			;;
		-f|--force)
			FORCE=1
			;;
		-h|--help)
			usage
			exit
			;;
		-i|--image)
			shift
			IMAGE=${1}
			;;
		-o|--download)
			DOWNLOAD=1
			;;
		-r|--reboot)
			REBOOT=1
			;;
		-s|--size)
			SIZE=${2}
			shift
			;;
		-t|--type)
			shift
			TYPE=${1}
			;;
		-u|--uefi)
			UEFI=1
			;;
		-*)
			pr_error "Unexpected option: ${1}"
			exit 2
			;;
		*)
			if [ -z "${DIST}" ] ; then
				DIST=${1}
			elif [ -z "${NAME}" ] ; then
				NAME=${1}
			else
				pr_error "Unexpected argument: ${1}"
				exit 2
			fi
			;;
	esac
	shift
done

if [ -z "${DIST}" ] ; then
	usage
	exit 2
fi

# -----------------------------------------------------------------------------
# Set global variables

# Defaults
IMAGES_DIR=/srv/cloud-images
CONFIG_DIR=$(dirname "$(realpath -e "${0}")")/config
VCPU=1
CPU=
MEMORY=768
NAME_SUFFIX=

# Set type specific variables
case "${TYPE}" in
	dep8)
		VCPU=2
		CPU="
<cpu mode='host-model' check='partial'>
  <model fallback='allow'/>
  <topology sockets='1' cores='1' threads='2'/>
</cpu>
"
		MEMORY=2048
		NAME_SUFFIX="-dep8"
		REBOOT=1
		;;
	"")
		;;
	*)
		pr_error "Invalid type: ${TYPE}"
		exit 1
		;;
esac

# The image vendor and release
case "${DIST}" in
	*-*)
		VENDOR=${DIST%-*}
		RELEASE=${DIST#*-}
		;;
	jessie|stretch|buster)
		VENDOR=debian
		RELEASE=${DIST}
		;;
	*)
		VENDOR=ubuntu
		RELEASE=${DIST}
		;;
esac

# The name of the VM
if [ -z "${NAME}" ] ; then
	NAME=${VENDOR}-${RELEASE}
	if [ ${UEFI} -eq 1 ] ; then
		NAME=${NAME}-uefi
	fi
	if [ -n "${ARCH}" ] ; then
		NAME=${NAME}-${ARCH}
	fi
	NAME=${NAME}${NAME_SUFFIX}
fi

# The vendor specific architecture name
case "${VENDOR}" in
	fedora|centos)
		if [ -z "${ARCH}" ] ; then
			ARCH=$(dpkg-architecture -q DEB_HOST_GNU_CPU)
		fi
		;;
	*)
		if [ -z "${ARCH}" ] ; then
			ARCH=$(dpkg-architecture -q DEB_HOST_ARCH)
		fi
		;;
esac

# The OS image and config drive
OS_IMAGE=${NAME}.qcow2
CONFIG_DRIVE=${NAME}-config.iso

# The kernel, initrd and cmdline (for direct boot architectures)
KERNEL=
INITRD=
if has_direct_boot ; then
	KERNEL=${NAME}-kernel
	INITRD=${NAME}-initrd
fi

# Sanity check
if [ "${RELEASE}" = "precise" ] && [ "${UEFI}" -eq 1 ] ; then
	pr_error "Precise does not support boot from UEFI"
	exit 1
fi

print_var NAME VCPU MEMORY ARCH FORCE VENDOR DIST RELEASE OS_IMAGE \
		  CONFIG_DRIVE KERNEL INITRD
echo

# -----------------------------------------------------------------------------
# Purge existing VM

if virsh dumpxml "${NAME}" >/dev/null 2>&1 ; then
	if [ "${FORCE}" -eq 0 ] ; then
		pr_error "VM '${NAME}' exists already. Use -f, --force to recreate it."
		exit 1
	fi
	virsh destroy "${NAME}" || true
	for vol in "${OS_IMAGE}" "${CONFIG_DRIVE}" "${KERNEL}" "${INITRD}" ; do
		virsh vol-delete --pool default "${vol}" 2>/dev/null || true
	done
	virsh undefine "${NAME}" || true
fi

# -----------------------------------------------------------------------------
# Download and resize the cloud image

if virsh vol-info --pool default "${OS_IMAGE}" >/dev/null 2>&1 ; then
	pr_info "Image '${OS_IMAGE}' exists already."
else
	download_"${VENDOR}"_image
fi

# -----------------------------------------------------------------------------
# Create the config drive

if virsh vol-info --pool default "${CONFIG_DRIVE}" >/dev/null 2>&1 ; then
	pr_info "Config drive '${CONFIG_DRIVE}' exists already."
else
	create_config_drive
fi

# -----------------------------------------------------------------------------
# Define the VM

define_vm
