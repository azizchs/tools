#!/bin/bash -eu
#
# Create a base libvirt guest VM
#

function pr_error()
{
	echo -e "\033[31m${*}\033[0m" 1>&2
}

function pr_info()
{
	echo -e "\033[33m${*}\033[0m"
}

function out()
{
	local rc=${?}

	trap - EXIT INT TERM HUP
	rm -rf "${TMP_DIR}"

	exit "${rc}"
}

function run()
{
	local rc
	set +e
	( set -e; "${@}" )
	RC=$?
	set -e
}

function print_var()
{
	local var val

	for var in "${@}" ; do
		val=${!var}
		if [ -n "${val}" ] ; then
			pr_info "$(printf "%-13s: %s\n" "${var}" "${val}")"
		fi
	done
}

function mount_image()
{
	local image=${1} mountp=${2}
	local kernel

	# HACK: guestmount needs to be able to read the latest kernel
	kernel=$(find /boot/ -maxdepth 1 -name 'vmlinuz-*' | sort -V | tail -1)
	test -r "${kernel}" || sudo chmod 644 "${kernel}"

	guestmount --pid-file "${mountp}.pid" -a "${image}" -m /dev/sda1 --rw \
			   -o dev -o allow_root "${mountp}"
}

function unmount_image()
{
	local mountp=${1}
	local pid count

	pid=$(cat "${mountp}.pid")
	guestunmount "${mountp}"

	count=10
	while kill -0 "${pid}" 2>/dev/null && [ ${count} -gt 0 ] ; do
		sleep 1
		((count--))
	done

	if [ ${count} -eq 0 ] ; then
		pr_error "Failed to unmount image (timeout)"
		exit 1
	fi

	rm -f "${mountp}.pid"
}

function download_image()
{
	local url=${1}
	local tmp_img tmp_xml image suffix tmp_dir

	tmp_img=$(mktemp -p "${TMP_DIR}")
	tmp_xml=$(mktemp -p "${TMP_DIR}")

	# Select the image to use
	if [ -n "${IMAGE}" ] ; then
		# Use the provided image
		cp "${IMAGE}" "${tmp_img}"
	else
		image=${IMAGES_DIR}/${url##*/}
		suffix=
		if [ "${image%.xz}" != "${image}" ] ; then
			image=${image%.xz}
			suffix=.xz
		fi
		if [ -e "${image}" ] && [ "${DOWNLOAD}" -eq 0 ] ; then
			# Used the cached image
			cp "${image}" "${tmp_img}"
		else
			# Download the image, decompress it and copy it to the cache
			wget -O "${tmp_img}${suffix}" "${url}"
			if [ -n "${suffix}" ] ; then
				unxz -f "${tmp_img}${suffix}"
			fi
			sudo cp "${tmp_img}" "${image}"
			sudo chmod 644 "${image}"
		fi
	fi

	# Extract the kernel and initrd from the image for direct boot
	if [ "${BOOT_MODE}" = "db" ] ; then
		tmp_dir=$(mktemp -d -p "${TMP_DIR}")

		mount_image "${tmp_img}" "${tmp_dir}"

		# Create the libvirt volume for the kernel
		cat <<EOF >"${tmp_xml}"
<volume type='file'>
  <name>${KERNEL}</name>
  <capacity unit='bytes'>0</capacity>
  <target>
    <format type='raw'/>
  </target>
</volume>
EOF
		virsh vol-create --pool default "${tmp_xml}"
		virsh vol-upload --pool default "${KERNEL}" "${tmp_dir}/boot/vmlinuz"

		# Create the libvirt volume for the initrd
		cat <<EOF >"${tmp_xml}"
<volume type='file'>
  <name>${INITRD}</name>
  <capacity unit='bytes'>0</capacity>
  <target>
    <format type='raw'/>
  </target>
</volume>
EOF
		virsh vol-create --pool default "${tmp_xml}"
		virsh vol-upload --pool default "${INITRD}" "${tmp_dir}/boot/initrd.img"

		unmount_image "${tmp_dir}"
	fi

	# Create the libvirt volume for the OS image
	cat <<EOF >"${tmp_xml}"
<volume type='file'>
  <name>${OS_IMAGE}</name>
  <capacity unit='bytes'>0</capacity>
  <target>
    <format type='qcow2'/>
  </target>
</volume>
EOF
	virsh vol-create --pool default "${tmp_xml}"
	virsh vol-upload --pool default "${OS_IMAGE}" "${tmp_img}"
	virsh vol-resize --pool default "${OS_IMAGE}" "${SIZE}"G
}

function download_fedora_image()
{
	local url pattern name

	if [ "${RELEASE}" -gt 27 ] ; then
		url=https://download.fedoraproject.org/pub/fedora/linux/releases/${RELEASE}/Cloud/${ARCH}/images
	else
		url=https://download.fedoraproject.org/pub/fedora/linux/releases/${RELEASE}/CloudImages/${ARCH}/images
	fi

	pattern=">Fedora-Cloud-Base-${RELEASE}-.*\.${ARCH}\.qcow2<"
	name=$(wget -q -O - "${url}" | grep -oP "${pattern}" | tr -d '><')

	url=${url}/${name}

	download_image "${url}"
}

function download_debian_image()
{
	local num name url release

	case "${RELEASE}" in
		jessie)  num=8  ;;
		stretch) num=9  ;;
		buster)  num=10 ;;
	esac

	name=debian-${num}-openstack-${ARCH}.qcow2
	url=https://cdimage.debian.org/cdimage/openstack/current-${num}/${name}

	run download_image "${url}"
	if [ "${RC}" -eq 0 ] ; then
		return
	fi

	url=https://cdimage.debian.org/cdimage/openstack/archive
	release=$(wget -q -O - "${url}" | grep -oP ">${num}\.[^/]*/<" | \
				  tr -d '>/<' | sort -V | tail -1)
	name=debian-${release}-openstack-${ARCH}.qcow2
	url=${url}/${release}/${name}

	download_image "${url}"
}

function download_ubuntu_image()
{
	local suffix name url

	suffix=
	if [ "${RELEASE}" = "precise" ] || [ "${RELEASE}" = "trusty" ] || \
		   [ "${RELEASE}" = "xenial" ] ; then
		suffix="-disk1"
		if [ "${BOOT_MODE}" = "uefi" ] ; then
			suffix="-uefi1"
		fi
	fi

	name=${RELEASE}-server-cloudimg-${ARCH}${suffix}.img
	url=https://cloud-images.ubuntu.com/${RELEASE}/current/${name}

	download_image "${url}"
}

function download_core_image()
{
	local name build url

	name=ubuntu-core-${RELEASE}-${ARCH}.img.xz
	for build in current pending ; do
		url=http://cdimage.ubuntu.com/ubuntu-core/${RELEASE}/${build}/${name}
		run download_image "${url}"
		if [ "${RC}" -eq 0 ] ; then
			return
		fi
	done

	pr_error "Failed to download core image: ${name}"
	exit 1
}

function create_config_drive()
{
	local public_key tmp_img tmp_xml tmp_dir

	public_key=$(cat ~/.ssh/id_rsa.pub)

	tmp_img=$(mktemp -p "${TMP_DIR}")
	tmp_xml=$(mktemp -p "${TMP_DIR}")
	tmp_dir=$(mktemp -d -p "${TMP_DIR}")

	# meta data
	cat <<EOF >"${tmp_dir}/meta-data"
{ instance-id: $(uuidgen) }
EOF

	# user data
	cat <<EOF >"${tmp_dir}/user-data"
#cloud-config

hostname: ${NAME}.localdomain
manage_etc_hosts: localhost

chpasswd: { expire: false }
password: ${VENDOR}
ssh_authorized_keys: [ ${public_key} ]
ssh_pwauth: true

# Datasource timeout
max_wait: 2

# Set the hostname early on first boot
bootcmd:
  - [ cloud-init-per, once, hostname, hostname, ${NAME} ]

# Copy the content of the config drive and run the create-vm init script
runcmd:
  - |
    if ! [ -d /etc/cloud/cidata ] ; then
    test -d /mnt/cidata || mkdir /mnt/cidata
    dev=\$(findfs LABEL=cidata)
    mount \${dev} /mnt/cidata
    cp -aR /mnt/cidata/ /etc/cloud/
    umount /mnt/cidata
    /etc/cloud/cidata/create-vm &
    fi
EOF

	# Copy the create-vm init script
	cp "${CONFIG_DIR}"/create-vm/create-vm "${tmp_dir}"
	sed -i -e "s,__REBOOT__,${REBOOT}," "${tmp_dir}"/create-vm

	# Copy the APT ESM sources list
	if [ -e "${CONFIG_DIR}/${RELEASE}-esm-ppa.list" ] ; then
		cp "${CONFIG_DIR}/${RELEASE}-esm-ppa.list" "${tmp_dir}"/esm-ppa.list
	fi

	# Create the config drive ISO image
	genisoimage -ldots -allow-lowercase -allow-multidot -l -J -r \
				-o "${tmp_img}" -V cidata "${tmp_dir}"

	# Create the libvirt volume for the config drive
	cat <<EOF >"${tmp_xml}"
<volume type='file'>
  <name>${CONFIG_DRIVE}</name>
  <capacity unit='bytes'>0</capacity>
  <target>
    <format type='raw'/>
  </target>
</volume>
EOF
	virsh vol-create --pool default "${tmp_xml}"
	virsh vol-upload --pool default "${CONFIG_DRIVE}" "${tmp_img}"
}

function define_vm()
{
	local tmp_xml

	tmp_xml=$(mktemp -p "${TMP_DIR}")

	# Defaults
	XML_UEFI_BEGIN="<!--"
	XML_UEFI_END="-->"
	XML_DIRECT_BOOT_BEGIN="<!--"
	XML_DIRECT_BOOT_END="-->"
	XML_OS_IMAGE_DISK_SATA_BEGIN="<!--"
	XML_OS_IMAGE_DISK_SATA_END="-->"
	XML_OS_IMAGE_DISK_VIRTIO_BEGIN="<!--"
	XML_OS_IMAGE_DISK_VIRTIO_END="-->"
	XML_CONFIG_DRIVE_DISK_BEGIN="<!--"
	XML_CONFIG_DRIVE_DISK_END="-->"

	# Arch-specific XML settings
	case "${ARCH}" in
		i386|i686)
			XML_ARCH=i686
			;;
		amd64|x86_64)
			XML_ARCH=x86_64
			;;
		s390x)
			XML_ARCH=s390x
			;;
		arm64)
			XML_ARCH=aarch64
			;;
		armhf)
			XML_ARCH=armv7l
			;;
		*)
			echo "Unsupported architecture: ${ARCH}" >&2
			exit 1
			;;
	esac

	if [ "${BOOT_MODE}" = "uefi" ] ; then
		XML_UEFI_BEGIN=
		XML_UEFI_END=
	fi

	if [ "${BOOT_MODE}" = "db" ] ; then
		XML_KERNEL_PATH=$(virsh vol-path --pool default "${KERNEL}")
		XML_INITRD_PATH=$(virsh vol-path --pool default "${INITRD}")
		XML_DIRECT_BOOT_BEGIN=
		XML_DIRECT_BOOT_END=
	fi

	XML_OS_IMAGE_PATH=$(virsh vol-path --pool default "${OS_IMAGE}")
	if [ "${VENDOR}" = "core" ] ; then
		XML_OS_IMAGE_DISK_SATA_BEGIN=
		XML_OS_IMAGE_DISK_SATA_END=
	else
		XML_OS_IMAGE_DISK_VIRTIO_BEGIN=
		XML_OS_IMAGE_DISK_VIRTIO_END=
	fi

	if [ -n "${CONFIG_DRIVE}" ] ; then
		XML_CONFIG_DRIVE_PATH=$(virsh vol-path --pool default "${CONFIG_DRIVE}")
		XML_CONFIG_DRIVE_DISK_BEGIN=
		XML_CONFIG_DRIVE_DISK_END=
	fi

	XML_NAME=${NAME}
	XML_UUID=$(uuidgen)
	XML_MEMORY=${MEMORY}
	XML_VCPU=${VCPU}
	XML_CPU=${CPU}
	XML_MAC_ADDRESS="52:54:00:${XML_UUID:0:2}:${XML_UUID:2:2}:${XML_UUID:4:2}"

	# Export the variables for the domain XML
	# shellcheck disable=SC2090
	export XML_ARCH
	export XML_UEFI_BEGIN XML_UEFI_END
	export XML_KERNEL_PATH XML_INITRD_PATH \
		   XML_DIRECT_BOOT_BEGIN XML_DIRECT_BOOT_END
	export XML_OS_IMAGE_PATH \
		   XML_OS_IMAGE_DISK_SATA_BEGIN XML_OS_IMAGE_DISK_SATA_END \
		   XML_OS_IMAGE_DISK_VIRTIO_BEGIN XML_OS_IMAGE_DISK_VIRTIO_END
	export XML_CONFIG_DRIVE_PATH \
		   XML_CONFIG_DRIVE_DISK_BEGIN XML_CONFIG_DRIVE_DISK_END
	export XML_NAME XML_UUID XML_MEMORY XML_VCPU XML_CPU XML_MAC_ADDRESS

	# Create the domain XML and define the VM
	envsubst < "${CONFIG_DIR}/create-vm/domain-${XML_ARCH}.xml" > \
			 "${tmp_xml}"
	virsh define "${tmp_xml}"
}

function usage()
{
	cat <<EOF
Usage: create-vm [-a ARCH] [-d] [-f] [-h] [-i IMAGE] [-o] [-r] [-s SIZE]
                 [-t TYPE] [-u] [-y] DIST [NAME]

Create a libvirt guest VM.

Positional arguments:
  DIST  A recognized distrbution, like bionic, stretch, fedora-26, ...
  NAME  The libvirt domain name. If not specified, defaults to
        <DIST>[-uefi][-<ARCH>].

Optional arguments:
  -a, --arch ARCH    Architecture of the VM. If not specified, defaults to the
                     host architecture.
  -d, --debug        Enable debugging (set -x).
  -f, --force        Force the recreation of an existing VM.
  -h, --help         Show this help text and exit.
  -i, --image IMAGE  Use image <IMAGE> as the guest VM image.
  -o, --download     Download and use a new cloud image rather than using an
                     already cached image.
  -r, --reboot       Configure the VM to automatically reboot after the
                     first boot initialization is done.
  -s, --size SIZE    Image size in GB. If not specified, defaults to 8(GB).
  -t, --type TYPE    Create a VM of type <TYPE>. Valid types are:
                       dep8:  For dep8 kernel testing.
  -u, --uefi         Configure the VM to boot from UEFI.
  -y, --dry-run
EOF
}

# -----------------------------------------------------------------------------
# Main entry point

ARCH=
FORCE=0
IMAGE=
DOWNLOAD=0
REBOOT=0
SIZE=8
TYPE=
BOOT_MODE=
DIST=
NAME=
DRY_RUN=0

while [ ${#} -gt 0 ] ; do
	case ${1} in
		-a|--arch)
			ARCH=${2}
			shift
			;;
		-d|--debug)
			export LIBGUESTFS_DEBUG=1
			set -x
			;;
		-f|--force)
			FORCE=1
			;;
		-h|--help)
			usage
			exit
			;;
		-i|--image)
			shift
			IMAGE=${1}
			;;
		-o|--download)
			DOWNLOAD=1
			;;
		-r|--reboot)
			REBOOT=1
			;;
		-s|--size)
			SIZE=${2}
			shift
			;;
		-t|--type)
			shift
			TYPE=${1}
			;;
		-u|--uefi)
			BOOT_MODE="uefi"
			;;
		-y|--dry-run)
			DRY_RUN=1
			;;
		-*)
			pr_error "Unexpected option: ${1}"
			exit 2
			;;
		*)
			if [ -z "${DIST}" ] ; then
				DIST=${1}
			elif [ -z "${NAME}" ] ; then
				NAME=${1}
			else
				pr_error "Unexpected argument: ${1}"
				exit 2
			fi
			;;
	esac
	shift
done

if [ -z "${DIST}" ] ; then
	usage
	exit 2
fi

# -----------------------------------------------------------------------------
# Set global variables

# Defaults
IMAGES_DIR=/srv/cloud-images
CONFIG_DIR=$(dirname "$(readlink -e "${0}")")/config
VCPU=1
CPU=
MEMORY=1024
NAME_SUFFIX=

# Set type specific variables
case "${TYPE}" in
	dep8)
		VCPU=2
		CPU="
<cpu mode='host-model' check='partial'>
  <model fallback='allow'/>
  <topology sockets='1' cores='1' threads='2'/>
</cpu>
"
		MEMORY=2048
		NAME_SUFFIX="-dep8"
		REBOOT=1
		;;
	"")
		;;
	*)
		pr_error "Invalid type: ${TYPE}"
		exit 1
		;;
esac

# The image vendor and release
case "${DIST}" in
	*-*)
		VENDOR=${DIST%-*}
		RELEASE=${DIST#*-}
		;;
	jessie|stretch|buster)
		VENDOR=debian
		RELEASE=${DIST}
		;;
	core*)
		VENDOR=core
		RELEASE=${DIST#core}
		;;
	*)
		VENDOR=ubuntu
		RELEASE=${DIST}
		;;
esac

# Sanity check
if [ "${RELEASE}" = "precise" ] && [ "${BOOT_MODE}" = "uefi" ] ; then
	pr_error "Precise does not support boot from UEFI"
	exit 1
fi

# The vendor specific host architecture name
case "${VENDOR}" in
	fedora|centos)
		HOST_ARCH=$(dpkg-architecture -qDEB_HOST_GNU_CPU)
		;;
	*)
		HOST_ARCH=$(dpkg-architecture -qDEB_HOST_ARCH)
		;;
esac

# Set the image architecture if not specified
if [ -z "${ARCH}" ] ; then
	ARCH=${HOST_ARCH}
fi

# Set the boot mode
if [ "${RELEASE}" = "xenial" ] && [ "${ARCH}" = "arm64" ] ; then
	BOOT_MODE="uefi"
elif [ "${ARCH}" = "armhf" ] ; then
	BOOT_MODE="db"
fi

# The name of the VM
if [ -z "${NAME}" ] ; then
	NAME=${VENDOR}-${RELEASE}
	if [ "${ARCH}" != "${HOST_ARCH}" ] ; then
		NAME=${NAME}-${ARCH}
	fi
	if [ -n "${BOOT_MODE}" ] ; then
		NAME=${NAME}-${BOOT_MODE}
	fi
	NAME=${NAME}${NAME_SUFFIX}
fi

# The image filenames
OS_IMAGE=${NAME}.img
CONFIG_DRIVE=${NAME}-config.iso
KERNEL=${NAME}-kernel
INITRD=${NAME}-initrd

if [ "${VENDOR}" = "core" ] ; then
	CONFIG_DRIVE=
	if [ "${RELEASE}" = "20" ] && [ "${SIZE}" -lt 12 ] ; then
		SIZE=12
	fi
fi
if [ "${BOOT_MODE}" != "db" ] ; then
	KERNEL=
	INITRD=
fi

print_var NAME VCPU MEMORY ARCH FORCE VENDOR DIST RELEASE OS_IMAGE \
		  CONFIG_DRIVE BOOT_MODE KERNEL INITRD

echo

if [ "${DRY_RUN}" -eq 1 ] ; then
	echo "(dry-run) Exiting..."
	exit
fi

# -----------------------------------------------------------------------------
# Purge existing VM

if virsh dumpxml "${NAME}" >/dev/null 2>&1 ; then
	if [ "${FORCE}" -eq 0 ] ; then
		pr_error "VM '${NAME}' exists already. Use -f, --force to recreate it."
		exit 1
	fi
	virsh destroy "${NAME}" || true
	for vol in "${OS_IMAGE}" "${CONFIG_DRIVE}" "${KERNEL}" "${INITRD}" ; do
		virsh vol-delete --pool default "${vol}" 2>/dev/null || true
	done
	virsh undefine --nvram "${NAME}" || true
fi

# -----------------------------------------------------------------------------
# Create a temporary working directory and install a cleanup handler

TMP_DIR=$(mktemp -d)
trap "out" EXIT INT TERM HUP

# -----------------------------------------------------------------------------
# Download and resize the cloud image

if virsh vol-info --pool default "${OS_IMAGE}" >/dev/null 2>&1 ; then
	pr_info "Image '${OS_IMAGE}' exists already."
else
	download_"${VENDOR}"_image
fi

# -----------------------------------------------------------------------------
# Create the config drive

if [ -n "${CONFIG_DRIVE}" ] ; then
	if virsh vol-info --pool default "${CONFIG_DRIVE}" >/dev/null 2>&1 ; then
		pr_info "Config drive '${CONFIG_DRIVE}' exists already."
	else
		create_config_drive
	fi
fi

# -----------------------------------------------------------------------------
# Define the VM

define_vm
